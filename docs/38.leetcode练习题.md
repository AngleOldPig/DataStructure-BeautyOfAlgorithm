# 各部分的必知必会&LeetCode练习题

## 1.数组和链表

**关于数组和链表的几个必知必会的代码实现**

**数组：**

- 实现一个支持动态扩容的数组
- 实现一个大小固定的有序数组，支持动态增删改操作
- 实现两个有序数组合并为一个有序数组

**链表：**

- 实现单链表、循环链表、双向链表，支持增删操作
- 实现单链表反转
- 实现两个有序的链表合并为一个有序链表
- 实现求链表的中间结点

**对应的 LeetCode 练习题**

**数组：**

Three Sum（求三数之和）

https://leetcode-cn.com/problems/3sum/

Majority Element（求众数）

https://leetcode-cn.com/problems/majority-element/

Missing Positive（求缺失的第一个正数）

https://leetcode-cn.com/problems/first-missing-positive/

**链表：**

Linked List CycleI（环形链表）

https://leetcode-cn.com/problems/linked-list-cycle/

Merge k Sorted Lists（合并k个排序链表）

https://leetcode-cn.com/problems/merge-k-sorted-lists/

## 2.栈、队列和递归

**关于栈、队列和递归的几个必知必会的代码实现**

**栈：**

- 用数组实现一个顺序栈
- 用链表实现一个链式栈
- 编程模拟实现一个浏览器的前进、后退功能

**队列：**

- 用数组实现一个顺序队列
- 用链表实现一个链式队列
- 实现一个循环队列

**递归：**

- 编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2)
- 编程实现求阶乘 n!
- 编程实现一组数据集合的全排列

**对应的 LeetCode 练习题**

**栈：**

Valid Parentheses（有效的括号）

https://leetcode-cn.com/problems/valid-parentheses/

Longest Valid Parentheses（最长有效的括号）

https://leetcode-cn.com/problems/longest-valid-parentheses/

Evaluate Reverse Polish Notatio（逆波兰表达式求值）

https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/

**队列：**

Design Circular Deque（设计一个双端队列）

https://leetcode-cn.com/problems/design-circular-deque/

Sliding Window Maximum（滑动窗口最大值）

https://leetcode-cn.com/problems/sliding-window-maximum/

**递归：**

Climbing Stairs（爬楼梯）

https://leetcode-cn.com/problems/climbing-stairs/

## 3.排序和二分查找

**关于排序和二分查找的几个必知必会的代码实现**

排序：

- 实现归并排序、快速排序、插入排序、冒泡排序、选择排序
- 编程实现 O(n) 时间复杂度内找到一组数据的第 K 大元素

二分查找：

- 实现一个有序数组的二分查找算法
- 实现模糊二分查找算法（比如大于等于给定值的第一个元素）

**对应的 LeetCode 练习题**

Sqrt(x) （x 的平方根）

https://leetcode-cn.com/problems/sqrtx/

## 4.散列表和字符串

**关于散列表和字符串的 4 个必知必会的代码实现**

散列表:

- 实现一个基于链表法解决冲突问题的散列表
- 实现一个 LRU 缓存淘汰算法

字符串:

- 实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树
- 实现朴素的字符串匹配算法

**对应的LeetCode练习题**

字符串

- Reverse String （反转字符串）

https://leetcode-cn.com/problems/reverse-string/

- Reverse Words in a String（翻转字符串里的单词）

https://leetcode-cn.com/problems/reverse-words-in-a-string/

- String to Integer (atoi)（字符串转换整数 (atoi)）

https://leetcode-cn.com/problems/string-to-integer-atoi/

## 5.二叉树和堆

**关于二叉树和堆的 7 个必知必会的代码实现**

二叉树

- 实现一个二叉查找树，并且支持插入、删除、查找操作
- 实现查找二叉查找树中某个节点的后继、前驱节点
- 实现二叉树前、中、后序以及按层遍历

堆

- 实现一个小顶堆、大顶堆、优先级队列
- 实现堆排序
- 利用优先级队列合并 K 个有序数组
- 求一组动态数据集合的最大 Top K

**对应的 LeetCode 练习题**

- Invert Binary Tree（翻转二叉树）

https://leetcode-cn.com/problems/invert-binary-tree/

- Maximum Depth of Binary Tree（二叉树的最大深度）

https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

- Validate Binary Search Tree（验证二叉查找树）

https://leetcode-cn.com/problems/validate-binary-search-tree/

- Path Sum（路径总和）

https://leetcode-cn.com/problems/path-sum/

## 6.图

**关于图的几个必知必会的代码实现**

图

- 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法
- 实现图的深度优先搜索、广度优先搜索
- 实现 Dijkstra 算法、A* 算法
- 实现拓扑排序的 Kahn 算法、DFS 算法

**对应的 LeetCode 练习题**

- Number of Islands（岛屿的个数）

https://leetcode-cn.com/problems/number-of-islands/description/

- Valid Sudoku（有效的数独）

https://leetcode-cn.com/problems/valid-sudoku/

## 7.贪心、分治、回溯和动态规划

**几种算法思想必知必会的代码实现**

回溯

- 利用回溯算法求解八皇后问题
- 利用回溯算法求解 0-1 背包问题

分治

- 利用分治算法求一组数据的逆序对个数

动态规划

- 0-1 背包问题
- 最小路径和（详细可看 @Smallfly 整理的 Minimum Path Sum）
- 编程实现莱文斯坦最短编辑距离
- 编程实现查找两个字符串的最长公共子序列
- 编程实现一个数据序列的最长递增子序列

**对应的 LeetCode 练习题**

- Regular Expression Matching（正则表达式匹配）

https://leetcode-cn.com/problems/regular-expression-matching/

- Minimum Path Sum（最小路径和）

https://leetcode-cn.com/problems/minimum-path-sum/

- Coin Change （零钱兑换）

https://leetcode-cn.com/problems/coin-change/

- Best Time to Buy and Sell Stock（买卖股票的最佳时机）

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

- Maximum Product Subarray（乘积最大子序列）

https://leetcode-cn.com/problems/maximum-product-subarray/

- Triangle（三角形最小路径和）

https://leetcode-cn.com/problems/triangle/





# 2道练习题

## 测试题1

电商交易系统中，订单数据一般都会很大，我们一般都分库分表来存储。假设我们分了 10 个库并存储在不同的机器上，在不引入复杂的分库分表中间件的情况下，我们希望开发一个小的功能，能够快速地查询金额最大的前 K 个订单（K 是输入参数，可能是 1、10、1000、10000，假设最大不会超过 10 万）。**如果你是这个功能的设计开发负责人，你会如何设计一个比较详细的、可以落地执行的设计方案呢？**

为了方便你设计，我先交代一些必要的背景，在设计过程中，如果有其他需要明确的背景，你可以自行假设。

- 数据库中，订单表的金额字段上建有索引，我们可以通过 select order by limit 语句来获取数据库中的数据；
- 我们的机器的可用内存有限，比如只有几百 M 剩余可用内存。希望你的设计尽量节省内存，不要发生 Out of Memory Error。

**解析**

解决这个题目的基本思路我想你应该能想到，就是借助归并排序中的合并函数，这个我们在排序（下）以及堆的应用那一节中讲过。

我们从每个数据库中，通过 select order by limit 语句，各取局部金额最大的订单，把取出来的 10 个订单放到优先级队列中，取出最大值（也就是大顶堆堆顶数据），就是全局金额最大的订单。然后再从这个全局金额最大订单对应的数据库中，取出下一条订单（按照订单金额从大到小排列的），然后放到优先级队列中。一直重复上面的过程，直到找到金额前 K（K 是用户输入的）大订单。

从算法的角度看起来，这个方案非常完美，但是，从实战的角度来说，这个方案并不高效，甚至很低效。因为我们忽略了，数据库读取数据的性能才是这个问题的性能瓶颈。所以，我们要尽量减少 SQL 请求，每次多取一些数据出来，那一次性取出多少才合适呢？这就比较灵活、比较有技巧了。一次性取太多，会导致数据量太大，SQL 执行很慢，还有可能触发超时，而且，我们题目中也说了，内存有限，太多的数据加载到内存中，还有可能导致 Out of Memory Error。

所以，一次性不能取太多数据，也不能取太少数据，到底是多少，还要根据实际的硬件环境做 benchmark 测试去找最合适的。



## 测试题2

假设我们现在希望设计一个简单的海量图片存储系统，最大预期能够存储 1 亿张图片，并且希望这个海量图片存储系统具有下面这样几个功能：

- 存储一张图片及其它的元信息，主要的元信息有：图片名称以及一组 tag 信息。比如图片名称叫玫瑰花，tag 信息是{红色，花，情人节}；
- 根据关键词搜索一张图片，比如关键词是“情人节 花”“玫瑰花”；
- 避免重复插入相同的图片。这里，我们不能单纯地用图片的元信息，来比对是否是同一张图片，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。

我们希望自助开发一个简单的系统，不希望借助和维护过于复杂的三方系统，比如数据库（MySQL、Redis 等）、分布式存储系统（GFS、Bigtable 等），并且我们单台机器的性能有限，比如硬盘只有 1TB，内存只有 2GB，**如何设计一个符合我们上面要求，操作高效，且使用机器资源最少的存储系统呢？**

**解析**

这个问题可以分成两部分，第一部分是根据元信息的搜索功能，第二部分是图片判重。

第一部分，我们可以借助搜索引擎中的倒排索引结构。关于倒排索引我会在实战篇详细讲解，我这里先简要说下。

如题目中所说，一个图片会对应一组元信息，比如玫瑰花对应{红色，花，情人节}，牡丹花对应{白色，花}，我们可以将这种图片与元信息之间的关系，倒置过来建立索引。“花”这个关键词对应{玫瑰花，牡丹花}，“红色”对应{玫瑰花}，“白色”对应{牡丹花}，“情人节”对应{玫瑰花}。

当我们搜索“情人节 花”的时候，我们拿两个搜索关键词分别在倒排索引中查找，“花”查找到了{玫瑰花，牡丹花}，“情人节”查找到了{玫瑰花}，两个关键词对应的结果取交集，就是最终的结果了。

第二部分关于图片判重，我们要基于图片本身来判重，所以可以用哈希算法，对图片内容取哈希值。我们对哈希值建立散列表，这样就可以通过哈希值以及散列表，快速判断图片是否存在。

我这里只说说我的思路，这个问题中还有详细的内存和硬盘的限制。要想给出更加详细的设计思路，还需要根据这些限制，给出一个估算。详细的解答，我都放在在哈希算法（下）那一节里到了，你可以自己回去看。